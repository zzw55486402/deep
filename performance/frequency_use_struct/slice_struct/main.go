package main

import "fmt"

func main() {
	slice := make([]int, 10, 100)
	// 1. make([]T, len, cap)
	/*
		第一个参数是 []T，T 即元素类型，第二个参数是长度 len，即初始化的切片拥有多少个元素(值为元素类型的默认值)，
		第三个参数是容量 cap，容量是可选参数，默认等于长度。使用内置函数 len 和 cap 可以得到切片的长度和容量
	*/
	fmt.Println(slice, len(slice), cap(slice))

	/*
		容量是当前切片已经预分配的内存能够容纳的元素个数，如果往切片中不断地增加新的元素。如果超过了当前切片的容量，
		就需要分配新的内存，并将当前切片所有的元素拷贝到新的内存块上。因此为了减少内存的拷贝次数，容量在比较小的时候，
		一般是以 2 的倍数扩大的，例如 2 4 8 16 …，当达到 2048 时，会采取新的策略，避免申请内存过大，导致浪费。

		这里的重新分配内存就会存在当该切片是在其他函数中进行分配内存的时候 会让调用方的函数中的切片还是维持原样 而不是
		像当前函数内的切片一样变更了内存空间和值
	*/

	/*
		切片和数组很相似，按照下标进行索引。切片本质是一个数组片段的描述，包括了数组的指针，
		这个片段的长度和容量(不改变内存分配情况下的最大长度)。
			struct {
				ptr *[]T
				len int
				cap int
			}
		切片操作并不复制切片指向的元素，创建一个新的切片会复用原来切片的底层数组，因此切片操作是非常高效的。
		复制的切片会直接操作原来的底层数组，所以对于复制操作 我们有copy函数 这样避免大量内存得不到释放的问题
	*/
	a := make([]int, 2)
	copy(a, slice[3:5])
	fmt.Println(a)
	/*
		切片有三个属性，指针(ptr)、长度(len) 和容量(cap)。append 时有两种场景：
			当 append 之后的长度小于等于 cap，将会直接利用原底层数组剩余的空间。
			当 append 后的长度大于 cap 时，则会分配一块更大的区域来容纳新的底层数组。
		因此，为了避免内存发生拷贝，如果能够知道最终的切片的大小，预先设置 cap 的值能够获得最好的性能。
	*/
	slice2 := make([]int, 0, 10)
	for i := 0; i < 10; i++ {
		slice2 = append(slice2, i)
	}
	fmt.Println(slice2)

	/*
		切片的delete是没有方法的 需要通过append的形式来进行
		切片的底层是数组，因此删除意味着后面的元素需要逐个向前移位。每次删除的复杂度为 O(N)，
		因此切片不合适大量随机删除的场景，这种场景下适合使用链表。
	*/

	slice2 = append(slice2[:3], slice2[4:]...)
	fmt.Println(slice2)
	slice2 = slice2[:3+copy(slice2[3:], slice2[4:])]
	fmt.Println(slice2)

	// insert操作也是要通过append函数进行的
	slice2 = append(slice2[:3], append([]int{100}, slice2[3:]...)...)
	fmt.Println(slice2)

	// push 操作 通过append
	slice2 = append(slice2, 3)           // O(1)
	slice2 = append([]int{6}, slice2...) // O(n)
	fmt.Println(slice2)

	// pop
	/*
		这样会存在底层数组的元素不会发生改变的情况造成大量内存得不到释放 所以我们一般使用copy
		在已有切片的基础上进行切片，不会创建新的底层数组。因为原来的底层数组没有发生变化，内存会一直占用，
		直到没有变量引用该数组。因此很可能出现这么一种情况，原切片由大量的元素构成，但是我们在原切片的基础上切片，
		虽然只使用了很小一段，但底层数组在内存中仍然占据了大量空间，得不到释放。比较推荐的做法，使用 copy 替代 re-slice。
	*/
	slice2 = slice2[:len(slice2)-1] // 删除尾部 O(1)
	slice2 = slice2[1:]             // 删除头部 O(1)
	temp := make([]int, 10)
	copy(temp, slice2[3:])
	fmt.Println(temp)

	/*
		因为切片虽然只使用了最后 2 个元素，但是因为与原来 1M 的切片引用了相同的底层数组，底层数组得不到释放，
		因此，最终 100 MB 的内存始终得不到释放。而 lastNumsByCopy 仅消耗了 3.14 MB 的内存。这是因为，
		通过 copy，指向了一个新的底层数组，当 origin 不再被引用后，内存会被垃圾回收(garbage collector, GC)。
	*/

}
